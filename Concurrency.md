**Ссылки**

- https://habr.com/ru/post/578752/
- https://habr.com/ru/post/320152/

**Grand Central Dispatch**, больше известный как GCD – фреймворк, содержащий в себе языковые конструкции, позволяющие нам комфортно и достаточно просто управлять потоками, задачами для выполнения и ресурсами, которые нам необходимо захватить.

**Получить данные текущего потока** можно через выражение `Thread.current`. Чтобы узнать, является ли поток главным `Thread.isMainThread`.

**Чтобы сделать изменения в UI** нужно переводить выполнение в основной поток

**Queue** позволяет не думать о потоках, swift самостоятельно распределяет все по потокам, мы просто выбираем типы очередей. Т.е. потоками напрямую мы не управляем.

**Thread** - это абстракция

**Thread** не обязательно должен занимать отдельное ядро, система может имитировать многопоточность на одном ядре, переключаясь между потоками

Apple предоставляет несколько готовых очередей: Main (serial) и не сколько глобальных (cuncurrent)

**Метод** `print` может выполняться в **любом** потоке

**Клоужер в URLSession.shared.dataTask выполняется в фоновом потоке,** UI из которого не доступен. Чтобы вернуться в главный поток, необходимо использовать DispatchQueue.main.ansyc - он выполняет действия в главном потоке.

**DispatchQueue.main.async - выполняется асинхронно но в основном потоке**, это значит что код не ждет выстраивается в очередь по отношению к текущему, а выполняется сразуже, одновременно с текущим

**DispatchQueue.main.sync** - практически не используется. Синхронный метод блокирует фоновой поток

**Await Async - позволяет избавиться от каскадного вызова замыканий,** т.е. избавится от “пирамиды погибели“

**При использовании async метода, не нужно использовать Dispatch** - Swift берет всю работу на себя

**Асинхронную функцию можно вызвать только в асинхронном потоке**, в основном потоке вызвать нельзя. Т.е. async функции могут вызвать только async методы

**При использовании концепции async** - при выполнении сетевых запросов для сообщении об ошибке мы используем не Result, а throw - catch, поскольку в данном случае код становится похож на обычный синхронный

**Чтобы из синхронных методов вызвать асинхронные**, используется механизм Task